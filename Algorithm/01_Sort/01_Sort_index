목차 

1. 버블 Bubble  -> 로직이 비교적 간단. (데이터의 인접 요소끼리 비교하고, swap 연산을 수행하여 정렬하는 방식) 
2. 선택 Selection 
3. 삽입 insertion 
4. 큌 Quick
5. 병합 Merge
6. 기수 radix (기수란 ? 집합의 크기를 나타내는 말.)
7. 계수 Count


---------------------------------------------------------------------------------------
1. 버블 정렬 (Bubble Sort)
---------------------------------------------------------------------------------------
# 시간 복잡도  : O(n^2)
# 고려할 부분 o (아래 내용 참조)

< 버블 정렬의 핵심 이론 >
버블 정렬은 두 인접한 데이터의 크기를 비교해 정렬하는 방법. 
간단하게 구현 할 수 있지만, 시간 복잡도는 O(n2^)으로 다른 정렬알고리즘 보다 속도가 느린 편. 

* 방법 ㅣ 루프 (loop)를 돌면서 인접한 데이터 간의 Swap 연산으로 정렬. 
* 고려할 부분 ㅣ 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면, 그 영역 뒤에 있는 데이터가 모두 정렬되었다는 뜻이기 때문에, 프로세스를 종료해도 됨. 

(My 생각) 루프를 돌 때 마다 list.lengh - n 번째의 값이 순차적으로 커진 수로 변경 됨. 

---------------------------------------------------------------------------------------
2. 선택 정렬 (Selection Sort)
---------------------------------------------------------------------------------------
# 시간 복잡도  : O(n^2)
# 기술 면접 
# 코테에서 자주 나오진 않음.

대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법. 

(해결 방법) 최솟값 또는 최대값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap 하는 것이 선택 정렬의 핵심. 

< 선택 정렬 과정 >
1. 남은 정렬 부분( 정렬해야할 부분.)에서 최솟값 or 최댓값을 찾는다. 
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap 한다. 
3. 가장 앞에 있는 데이터의 위치를 변경해 (index ++) 남은 정렬 부분의 범위를 축소한다. 
4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다. 

---------------------------------------------------------------------------------------
3. 삽입 정렬 (Insertion Sort)
---------------------------------------------------------------------------------------
# 시간 복잡도  : O(n^2)
# 느린편이며, 구현하기 쉬움. 
# 구현 방법 및 동작 매커니즘은 확인 필요. 

< 핵심 이론 > 
선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것을 삽입 정렬의 핵심. .

< 삽입 정렬 과정 > 
1. 현재 인덱스에 있는 데이터 값을 선택한다. 
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색. 
3. 삽입 위치루터 인덱스에 있는 위치까지 Shift 연산을 수행한다. 
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index ++ 연산을 수행한다. 
5. 전체 데이터의 크기만큼 index 가 커질 때까지, 즉 선택한 데이터가 없을 때까지 반복한다. 


---------------------------------------------------------------------------------------
4. 퀵 정렬 (Quick Sort)
---------------------------------------------------------------------------------------
기준 값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘.

# 기준 값에 따라 시간 복잡도에 많은 영향을 미침. 
# 평균 시간 복잡도 : O(nlogn) / 최악 시간 복잡도 : O(n^2)

< 정렬 과정 >
1. 데이터를 분할하는 pivot을 설정한다. (예 : 가장 오른쪽 끝을 pivot으로 설정) * 투포인터 정렬을 사용
2. pivot 을 기준으로 다음 a ~ e 과정을 거쳐 데이처를 2개의 집합으로 분리.
    2-a ) start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽 1칸으로 이동. 
    2-b ) end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동.
    2-c ) start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면
          start, end가 가리키는 데이터를 swap 하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동. 
    2-d ) start와 end가 만날 때까지 윗 과정( 2-a ~ 2-c )을 반복 
    2-e ) start와 end가 만나면, 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 
          pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
3. 분리 집합에서 각각 다시 pivot을 선정한다. 
4. 분리 집합이 1개 이하가 될 때까지 과정 (1 ~ 3)을 반복한다. 


---------------------------------------------------------------------------------------
5. 병합 정렬 (Merge Sort) ********
---------------------------------------------------------------------------------------
분할 정복방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘이다. 

# 분할 정복의 방식 사용
# 시간 복잡도  : O(nlogn)
# 안정적 
# 코딩 테스트에서 이 이론을 응용한 문제가 많이 나옴(따로 코딩 예제 볼 것.)

< 핵심 이론 >
1. 가장 작은 데이터 집합으로 분할 
2. 데이터 집합 두개를 병합하여 정렬
3. 가장 큰 데이터 집합이 될 때 까지 2번을 반복 

-> 시간 복잡도가 왜 O(nlogn)인가? 
8개의 숫자를 정렬하는데 3번의 과정이 필요. -> (log 8 = 약 2^3)이며, 각 과정마다 8만큼 데이터 acess를 함. 
즉, N개의 숫자를 정렬할 때 N만큼의 데이터를 acess하며, 과정은 logN만큼 필요하기 때문에 시간 복잡도가 O(NlogN)임. 


<(가장 마지막 처리)2개의 데이터 그룹을 병합 과정> # 투 포인터 # 값을 역전하는 방법을 찾아보자! 
|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5||||||||

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15||||||| 

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15|24||||||

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15|24|32|||||

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15|24|32|42||||

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15|24|32|42|45|||

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15|24|32|42|45|60||

|24|32|42|60|5|15|45|90| --(작은 값 저장)-->  |5|15|24|32|42|45|60|90|


---------------------------------------------------------------------------------------
6. 기수 정렬 (radix Sort) * 주류는 아님. ( 하지만, 어려운 정렬 문제에서는 해당 알고리즘을 사용)
---------------------------------------------------------------------------------------

* 기수 정렬 : 값을 비교하지 않는 특이한 정렬. ( => 자릿수를 정한 다음에 "자릿수" 기준으로 비교.)
기수 정렬은 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교한다. 
기수 정렬의 시간 복잡도는 O(kn)으로 여기서 k는 데이터의 자릿수를 의미. 

<기수 정렬의 핵심 이론> 
기수 정렬은 10개의 큐를 이용. 각 큐는 값의 자릿수를 대표. (10개의 큐의 의미 => 한 자리에 올 수 있는 경우의 수 0~9를 담기위해)

(예제)
대상 데이터 16 80 18 77 24 88 23

1. -> 일의 자릿수를 기준으로 데이터 저장
|   | |   | |   | |   | |   | |   | |   | |   | |   | |   |
|   | |   | |   | | 23| |   | |   | |   | |   | | 88| |   |
| 80| |   | |   | | 03| | 24| |   | | 16| | 77| | 18| |   | 
  0     1     2     3     4     5     6     7     8     9   

2. -> 일의 자릿수를 기준으로 데이터 정렬
80 03 23 24 16 77 18 88

3. -> 십의 자릿수를 기준으로 데이터 저장 

|   | |   | |   | |   | |   | |   | |   | |   | |   | |   |
|   | | 18| | 24| |   | |   | |   | |   | |   | | 88| |   |
| 03| | 16| | 23| |   | |   | |   | |   | | 77| | 80| |   | 
  0     1     2     3     4     5     6     7     8     9   

4. -> 십의 자릿수를 기준으로 데이터 정렬
03 16 18 23 24 77 80 88


*** 기수 정렬은 시간 복잡도가 가장 짧음. 
*** Queue를 사용할 줄 알아야 하며, 다른 정렬에 비해 복잡하다. 





이해한 것. 
- 배열을 분할 할 때는 재귀 함수를 사용할 것 + 꼭 분할 이 안되는 경우를 고려 할 것. 
- 수를 특정할 수 없을 때는 While문을 이용할 것. 
- temp를 이용하면 본래 배열 값이 변경이 되도 괜찮음! (MergeSort 내용 참조.)
